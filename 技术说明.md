##  一、解码流程

![](/pic/pic1.png)

![代码](/pic/pic2.png)

## 二、Android C++ 线程简介

*安卓是基于Linux内核的，而Linux是遵循POSIX线程标准的，POSIX线程库中有一系列Pthreads API方便我们对Linux线程的操作。*

*所以我们在Android中使用C/C++线程也就转到了使用POSIX线程库。他们都在头文件“pthread.h”中*

### 1、创建子线程

- ***pthread_t***：用于声明一个线程对象如：***pthread_t thread***;

- ***pthread_creat***:用于创建一个实际的线程如***pthread_create(&pthread,NULL,threadCallBack,NULL)***;其总共接收4个参数，第一
                         个参数为***pthread_t***对象，第二个参数为线程的一些属性我们一般传
                         NULL就行，第三个参数为线程执行的函数（***void* threadCallBack(
                         void *data)***），第四个参数是传递给线程的参数是void*类型的既可
                         以传任意类型。
- ***pthread_exit***:用于退出线程如：***pthread_exit(&thread)***，参数也 可以传NULL。注：线程回调函数最后必须调用此方法，不然APP
                        会退出（挂掉）

### 2、生产者消费者模型
- ***pthread_mutex_t***:用于创建线程锁对象如:***pthread_mutex_t mutex***

- ***pthread_mutex_init***:用于初始化***pthread_mutex_t*** 锁对象如:***pthread_mutex_init(&mutex, NULL)***; 

- ***pthread_mutex_destroy***:用于销毁***pthread_mutex_t***锁对象如:***pthread_mutex_destroy(&mutex)***

- ***pthread_cond_t***:用于创建线程条件对象如:***pthread_cond_t cond***;

- ***pthread_cond_init***:用于初始化***pthread_cond_t***条件对象如:***pthread_cond_init(&cond, NULL)***;

- ***pthread_cond_destroy***:用于销毁***pthread_cond_t***条件对象如:***pthread_cond_destroy(&cond)***;

- ***pthread_mutex_lock***:用于上锁***mutex***,本线程上锁后的其他变量是不能被别的线程操作的如：***pthread_mutex_lock(&mutex)***

- ***pthread_mutex_unlock***:用于解锁***mutex***，解锁后的其他变量可以被其他线程操作如：***pthread_mutex_unlock(&mutex)***

- ***pthread_cond_signal***:用于发出条件信号如:***pthread_cond_signal(&mutex, &cond)***;

- ***pthread_cond_wait***;用于线程阻塞等待，直到***pthread_cond_signal***发出条件信号后才执行退出线程阻塞执行后面的操作;


## 三、C++多线程解码音频数据
### 1、注册解码器并初始化网络
*av_register_all()*;

*avformat_network_init()*;

### 2、打开文件或网络流
*AVFormatContext    * pFormatCtx = avformat_alloc_context()*

*avformat_open_input(&pFormatCtx, url, NULL, NULL)*

### 3、获取流信息
*avformat_find_stream_info(pFormatCtx, NULL)*

### 4、获取音频流
*pFormatCtx->streams[i]->codecpar->codec_type == AVMEDIA_TYPE_AUDIO*

### 5、获取解码器
*AVCodec   * dec = avcodec_find_decoder(audio->codecpar->codec_id)*

### 6、利用解码器创建解码器上下文
*AVCodecContext  * avCodecContext = avcodec_alloc_context3(dec)*
*avcodec_parameters_to_context(audio->avCodecContext, audio->codecpar)*

### 7、打开解码器
*avcodec_open2(audio->avCodecContext, dec,0)*

### 8、读取音频帧
*AVPacket * packet = av_packet_alloc()*
*av_read_frame(pFormatCtx, packet)*

## 四、C++队列（queue）
### 1、头文件
*# include “queue”*
### 2、创建队列
*std::queue<T> queue*
### 3、入队
*queue.push(t);*
### 4、出队
*T t = queue.front()*

*queue.pop()*

### 5、Avpacket 队列封装
```
//入队
putAvpacket(AVPacket *avPacket){
   //加锁
   pthread_mutex_lock(&mutexPacket);
   //入队
   queuePacket.push(avPacket);
   //发送消息给消费者
   pthread_cond_signal(&condPacket);
   //解锁
   pthread_mutex_unlock(&mutexPacket);
}
```
### 6、Avpacket 队列封装
```
//出队
getAvpacket(AVPacket *avPacket) {
   pthread_mutex_lock(&mutexPacket);
   while(playStatus != NULL && !playStatus->exit){
        if(queuePacket.size() > 0){
            AVPacket *pkt = queuePacket.front();
            if(av_packet_ref(avPacket, pkt) == 0) //把pkt的内存数据拷贝到avPacket内存中
            {
               queuePacket.pop();
            }
            av_packet_free(&pkt);
             av_free(pkt);
             pkt = NULL;
             break;
        }else{
             pthread_cond_wait(&condPacket, &mutexPacket);
        }
    }
    pthread_mutex_unlock(&mutexPacket);
}
```
## 五、OPenSL ES

### 1、使用流程
![](/pic/pic3.png)

### 2、重要接口解释
#####  (1) 类接口:SLObjectItf ,通过SLObjectItf接口类我们可以创建所需要的各种类型的类接口，比如:
-  创建引擎接口对象：***SLObjectItf engineObject***
-  创建混音器接口对象：***SLObjectItf outputMixObject***
-  创建播放器接口对象：***SLObjectItf playerObject***
##### (2)、具体的接口类
- 引擎：SLEngineItf
- 播放器：SLPlayItf
- 声音控制器:SLVolumeItf等等

### 3、创建引擎接口对象（createrealizeget）
```

```























